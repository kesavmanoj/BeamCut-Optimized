# Beam Cutting Optimization Web Application – Deep Technical Overview

This repository implements a full-stack, production-grade web application for optimizing beam cutting patterns to minimize material waste in manufacturing. The system is composed of a React frontend, a Node.js/Express backend, and a Python microservice for mathematical optimization, all orchestrated to provide a seamless user and developer experience.

---

## 1. System Architecture and Data Flow

### 1.1. High-Level Components

- **Frontend (client/):**  
  Built with React, Tailwind CSS, React Query, and Framer Motion. Handles all user interaction, project management, data upload, and visualization of optimization results.
- **Backend (server/):**  
  Node.js/Express API server. Manages authentication, project and file CRUD, analytics, and acts as a proxy to the Python optimization microservice. Connects to a PostgreSQL database (via Supabase in production).
- **Optimization Engine (optimization_py/):**  
  Python Flask microservice. Exposes a REST API for running the cutting stock optimization using PuLP (linear programming). Receives requests from the backend, processes them, and returns optimal cutting patterns and waste statistics.

### 1.2. Data and Control Flow

1. **User Interaction:**  
   Users interact with the React frontend (`client/src/`). They can create projects, upload beam requirements (Excel/CSV), and trigger optimizations.
2. **API Requests:**  
   The frontend communicates with the backend via RESTful API calls (`client/src/services/api.js`), targeting endpoints defined in `server/routes/`.
3. **Backend Processing:**  
   The backend validates requests (using Joi), manages project and file data in PostgreSQL, and, for optimization requests, forwards the relevant data to the Python microservice (`server/services/pythonOptimizationService.js`).
4. **Optimization Execution:**  
   The Python microservice (`optimization_py/app.py`) receives the request, validates and processes the input, runs the optimization algorithm, and returns results.
5. **Result Mapping:**  
   The backend passes the Python results back to the frontend. The frontend uses mapping utilities (`client/src/utils/optimizationMapping.js`) to transform backend data into a format suitable for visualization and further validation.
6. **Visualization and Debugging:**  
   The frontend displays results, including color-coded patterns, waste analysis, and debug information. Users can review, save, or export results.

---

## 2. Key Modules and Their Responsibilities

### 2.1. Frontend (client/)

- **src/App.js:**  
  Main React entry point. Sets up routing, error boundaries, and global providers (React Query).
- **src/pages/:**  
  Contains main page components (Dashboard, Projects, ProjectDetail, Optimization, Results, etc.).
- **src/components/:**  
  Reusable UI components (Layout, DebugPanel, ErrorBoundary, etc.).
- **src/services/api.js:**  
  Centralizes all API calls to the backend.
- **src/utils/optimizationMapping.js:**  
  Handles transformation and validation of optimization results. Debug level is configurable via environment or runtime setter.
- **src/utils/validation.js:**  
  Provides client-side validation utilities for user input and data mapping.

### 2.2. Backend (server/)

- **app.js:**  
  Configures the Express app, applies security (helmet, rate limiting), CORS, JSON parsing, static file serving (with authentication and sanitization for `/uploads`), and mounts all API routes.
- **index.js:**  
  Loads environment variables, starts the server, and attaches the Express app.
- **routes/:**  
  - `projects.js`: CRUD for projects and requirements.
  - `optimization.js`: Endpoints for running optimizations (single and range).
  - `upload.js`: Handles file uploads, validation, and storage (Supabase).
  - `analytics.js`, `reports.js`, `settings.js`: Analytics, reporting, and application settings.
- **services/pythonOptimizationService.js:**  
  Handles HTTP communication with the Python microservice, with robust error handling and timeouts.
- **services/logger.js:**  
  Centralized logging using Winston.
- **config/database.js:**  
  Sets up the PostgreSQL connection pool.
- **scripts/setupDatabase.js:**  
  Creates and migrates the database schema, including unique constraints and indexes.

### 2.3. Optimization Microservice (optimization_py/)

- **app.py:**  
  Flask app exposing `/health` and `/optimize` endpoints. Validates all input, runs the cutting stock optimization using PuLP, and returns results in a strict schema.
- **cutting_stock_solver.py:**  
  Implements the core optimization logic (column generation, integer programming).

---

## 3. Security, Validation, and Error Handling

- **Static File Serving:**  
  `/uploads` is protected by authentication and path sanitization middleware to prevent unauthorized access and directory traversal.
- **Input Validation:**  
  All API endpoints (backend and Python) use strict validation (Joi for Node.js, manual/type checks for Python).
- **Error Handling:**  
  All external service calls (Python microservice, Supabase, DB) are wrapped in try/catch with user-friendly error messages and detailed logging.
- **Database Constraints:**  
  Unique constraints are enforced for project names, uploaded file names per project, and report names per project/type.

---

## 4. Configuration and Environment

- **Backend:**  
  Configured via `server/.env` (see `env.example`). Key variables: `DATABASE_URL`, `PYTHON_OPTIMIZATION_URL`, `JWT_SECRET`, etc.
- **Frontend:**  
  Uses `client/.env` for API base URL and debug level.
- **Python Microservice:**  
  Runs on port 5001 by default. Expects requests from the backend only.

---

## 5. Testing and Quality Assurance

- **Backend:**  
  Uses Jest and Supertest. Tests cover API endpoints, error/404 handlers, and integration with the Python microservice.
- **Frontend:**  
  Uses React Testing Library and Jest for unit and integration tests.
- **Python Microservice:**  
  Uses pytest and requests. Tests cover core solver logic and Flask endpoints (`/health`, `/optimize` with valid/invalid data).
- **Validation and Mapping:**  
  Comprehensive mapping and validation utilities with debug levels and automated/manual test hooks.

---

## 6. Deployment and Operations

- **Vercel:**  
  Both frontend and backend are deployable to Vercel. The Python microservice should be deployed to a Python-compatible platform (e.g., Railway, Render).
- **Supabase:**  
  Used for managed PostgreSQL and file storage in production.
- **Environment Variables:**  
  All secrets and configuration are managed via environment variables, with example files provided.

---

## 7. Project Structure (Key Files and Directories)

```
copyDefiLend/
├── client/                 # React frontend
│   ├── src/
│   │   ├── components/     # UI components
│   │   ├── pages/          # Main pages
│   │   ├── services/       # API layer
│   │   └── utils/          # Mapping, validation
├── server/                 # Node.js backend
│   ├── routes/             # API endpoints
│   ├── services/           # Business logic, Python proxy
│   ├── config/             # DB config
│   ├── scripts/            # DB setup/migration
├── optimization_py/        # Python microservice
│   ├── app.py              # Flask API
│   └── cutting_stock_solver.py # Optimization logic
├── tests/                  # Automated tests (backend, frontend, python)
└── README.md               # This file
```

---

## 8. How the Program Runs (Step-by-Step)

1. **User opens the frontend** (served by React in `client/`).
2. **User creates a project** and uploads beam requirements (Excel/CSV or manual entry).
3. **Frontend sends API requests** to the backend (`server/`), which validates and stores project data.
4. **User triggers optimization** (single or range). The backend collects requirements and forwards them to the Python microservice.
5. **Python microservice validates input** and runs the optimization algorithm, returning the best cutting patterns and waste statistics.
6. **Backend stores results** in PostgreSQL and returns them to the frontend.
7. **Frontend maps and visualizes results** using mapping utilities, with debug and validation layers.
8. **User reviews, saves, or exports results** as needed.

---

For further details, see the code comments, mapping guides, and in-code documentation throughout the repository. 